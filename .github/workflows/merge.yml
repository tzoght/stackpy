name: merge

on:
  push:
    branches: ["main"] # only on main branch

permissions:
  contents: write
  pages: write
  id-token: write
  packages: write

concurrency:
  group: "${{ vars.REPO_NAME }}-${{ github.head_ref || github.ref_name }}"
  cancel-in-progress: false

env:
  ################################## REPOSITORY SPECIFIC ##################################
  # Specifies the Python version to be used in the workflow.
  PYTHON_VERSION: "3.12"
  # Repository name from GitHub variables
  REPO_NAME: "${{ vars.REPO_NAME }}"
  # Conda environment name (typically matches repo name)
  CONDA_ENV: "${{ vars.REPO_NAME }}"
  # PyPI library name (typically matches repo name)
  PYPI_LIBRARY_NAME: "${{ vars.REPO_NAME }}"
  # Repository full name for API calls
  REPO: "tzoght/${{ vars.REPO_NAME }}"
  # A Python import statement used for testing package installation.
  TEST_IMPORT: "${{ vars.TEST_IMPORT_STATEMENT }}"
  # Define the link to the release
  LINK_TO_RELEASES: "https://github.com/tzoght/${{ vars.REPO_NAME }}/releases"
  ####################################### DEFAULT #########################################

  ############################## DEFINED AS REPOSITORY SECRET #############################
  # GitHub token for authentication and package publishing
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # SEMVER_PAT
  SEMVER_PAT: ${{ secrets.SEMVER_GITHUB_PAT }}
  ############################## DEFINED AS REPOSITORY SECRET #############################

jobs:

  pre_check:
    runs-on: ubuntu-latest
    outputs:
        is_semver: ${{ steps.check_message.outputs.is_semver }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        # remove this line if you don't use git-lfs
        with:
          lfs: true

      # remove this job if you don't use git-lfs
      - name: Cache Git LFS objects
        id: cache-lfs
        uses: actions/cache@v4
        with:
          path: .git/lfs
          key: ${{ runner.os }}-git-lfs-${{ hashFiles('.gitattributes') }}
          restore-keys: |
            ${{ runner.os }}-git-lfs-

      # remove this job if you don't use git-lfs
      - name: Pull LFS files if cache miss
        if: steps.cache-lfs.outputs.cache-hit != 'true'
        run: |
          git lfs fetch
          git lfs checkout

      - name: Check Commit Message Format
        id: check_message
        run: |
          commit_message=$(git log --format=%B -n 1 HEAD)
          echo "Commit message: $commit_message"
          # Detect standard semantic versioning
          if [[ $commit_message =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            # echo "name=is_semver::true" >> $GITHUB_ENV
            echo "::set-output name=is_semver::true"
          # Detect multi-line messages that start with a semantic version
          elif echo "$commit_message" | grep -Pzq "^[0-9]+\.[0-9]+\.[0-9]+\n\nAutomatically generated by python-semantic-release"; then
            # echo "name=is_semver::true" >> $GITHUB_ENV
            echo "::set-output name=is_semver::true"
          else
            # echo "name=is_semver::false" >> $GITHUB_E
            echo "::set-output name=is_semver::false"
          fi
      
  merge:
    needs: pre_check
    if: needs.pre_check.outputs.is_semver == 'false'
    runs-on: ubuntu-latest

    steps:
    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: "${{ env.PYTHON_VERSION }}"

    - name: Check-out repository
      uses: actions/checkout@v4
      with:
        # important to keep it at 0 to get all tags
        fetch-depth: 0
        # this token is required for semantic-release
        token: ${{ secrets.SEMVER_GITHUB_PAT || secrets.GITHUB_TOKEN }}
        # remove this line if you don't use git-lfs
        lfs: true

    # remove this job if you don't use git-lfs
    - name: Cache Git LFS objects
      id: cache-lfs
      uses: actions/cache@v4
      with:
        path: .git/lfs
        key: ${{ runner.os }}-git-lfs-${{ hashFiles('.gitattributes') }}
        restore-keys: |
          ${{ runner.os }}-git-lfs-

    # remove this job if you don't use git-lfs
    - name: Pull LFS files if cache miss
      if: steps.cache-lfs.outputs.cache-hit != 'true'
      run: |
        git lfs fetch
        git lfs checkout

    - name: Install dependencies
      run: |
        conda env create -f environment.yml
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda init bash
        conda activate ${{ env.CONDA_ENV }}

    - name: Install ${{ env.PYPI_LIBRARY_NAME }} library using poetry
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda activate ${{ env.CONDA_ENV }}
        poetry install

    - name: Test with pytest
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda activate ${{ env.CONDA_ENV }}
        poetry run pytest tests/ --cov-branch --cov=src/${{ env.PYPI_LIBRARY_NAME }} --cov-report=xml:coverage-reports/coverage.xml
        ls -las coverage-reports/

    - name: SonarQube Scan
      uses: SonarSource/sonarqube-scan-action@v3
      env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

    # GitHub-hosted PyPI index deployment doesn't need special poetry configuration
    # The package will be attached to the GitHub release and indexed automatically

    - name: Semantic Release (GitHub Release Only)
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PRE_RELEASE: ${{ env.PRE_RELEASE }}
        SEMVER_PAT: ${{ secrets.SEMVER_GITHUB_PAT }}
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        echo "activating conda environment  ${{ env.CONDA_ENV }}"
        conda activate ${{ env.CONDA_ENV }}
        echo "activated conda environment  ${{ env.CONDA_ENV }}"
        git config user.name github-actions
        git config user.email github-actions@github.com
        poetry run semantic-release publish

    - name: Build Package for GitHub-hosted PyPI
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda activate ${{ env.CONDA_ENV }}
        
        # Build the package
        echo "ðŸ“¦ Building package for GitHub-hosted PyPI index..."
        poetry build
        
        # Show what was built
        echo "ðŸ“‹ Built packages:"
        ls -la dist/
        
        # The semantic-release step will create a GitHub release
        # We'll attach these artifacts to that release
        echo "âœ… Package built successfully! Artifacts will be attached to GitHub release."

    - name: Upload Release Assets
      if: success()
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda activate ${{ env.CONDA_ENV }}
        
        # Get the latest release (created by semantic-release)
        LATEST_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
        echo "ðŸ“‹ Latest release: $LATEST_RELEASE"
        
        if [ -n "$LATEST_RELEASE" ] && [ "$LATEST_RELEASE" != "null" ]; then
          echo "ðŸ“Ž Uploading built artifacts to release $LATEST_RELEASE..."
          gh release upload "$LATEST_RELEASE" dist/* --clobber
          echo "âœ… Artifacts uploaded to GitHub release!"
        else
          echo "âš ï¸ No release found to attach artifacts to."
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Update GitHub-hosted PyPI Index
      if: success()
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda activate ${{ env.CONDA_ENV }}
        
        # Get the latest release info
        LATEST_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
        PACKAGE_NAME="${{ env.PYPI_LIBRARY_NAME }}"
        REPO_URL="https://github.com/tzoght/${{ env.REPO_NAME }}"
        
        echo "ðŸ“‹ Updating GitHub-hosted PyPI index..."
        echo "  Package: $PACKAGE_NAME"
        echo "  Version: $LATEST_RELEASE"
        echo "  Repository: $REPO_URL"
        
        # Trigger the update workflow in the github-hosted-pypi repository
        echo "ðŸš€ Triggering PyPI index update workflow..."
        
        if [ -n "${{ secrets.PYPI_UPDATE_PAT }}" ]; then
          echo "Using PAT to trigger cross-repository workflow..."
          
          # Extract author from GitHub repository info
          AUTHOR=$(gh api repos/$GITHUB_REPOSITORY --jq '.owner.login' 2>/dev/null || echo "${GITHUB_REPOSITORY_OWNER}")
          
          # Use the register workflow with correct parameters
          gh workflow run register.yml \
            --repo tzoght/github-hosted-pypi \
            --field package_name="$PACKAGE_NAME" \
            --field version="$LATEST_RELEASE" \
            --field author="$AUTHOR" \
            --field short_desc="Python package: $PACKAGE_NAME" \
            --field homepage="$REPO_URL"
          
          echo "âœ… GitHub-hosted PyPI index update triggered!"
          echo "ðŸ”— Monitor the update at: https://github.com/tzoght/github-hosted-pypi/actions"
        else
          echo "âš ï¸ PYPI_UPDATE_PAT secret not found. Creating manual update instructions..."
          echo "ðŸ“ Manual PyPI index registration required:"
          echo "  1. Go to: https://github.com/tzoght/github-hosted-pypi/actions/workflows/register.yml"
          echo "  2. Click 'Run workflow'"
          echo "  3. Fill in the form with these values:"
          echo "     ðŸ“¦ Package name: $PACKAGE_NAME"
          echo "     ðŸ·ï¸ Version: $LATEST_RELEASE"
          echo "     ðŸ‘¤ Author: ${GITHUB_REPOSITORY_OWNER} (or your preferred author name)"
          echo "     ðŸ“ Short description: Python package: $PACKAGE_NAME (or provide your own description)"
          echo "     ðŸ  Homepage: $REPO_URL"
          echo "  4. Click 'Run workflow' to register in the index"
          echo ""
          echo "â„¹ï¸ Note: This will create a PR to add your package to the PyPI index"
          echo ""
          echo "ðŸ’¡ To automate this, create a PAT with 'actions:write' permission and store it as PYPI_UPDATE_PAT secret"
        fi
      env:
        GH_TOKEN: ${{ secrets.PYPI_UPDATE_PAT || secrets.GITHUB_TOKEN }}

    - name: Get ${{ env.PYPI_LIBRARY_NAME }} version
      id: get_version
      run: |
          echo "Initialize Conda"
          eval "$(conda shell.bash hook)"
          conda init bash
          conda activate ${{ env.CONDA_ENV }}
          echo "LIB_VERSION=$(poetry version --short)" >> $GITHUB_ENV

    - name: Test installation from GitHub-hosted PyPI Index
      run: |
          echo "Initialize Conda"
          eval "$(conda shell.bash hook)"
          conda init bash
          conda create --name test_env python=${{ env.PYTHON_VERSION }}
          conda activate test_env
          echo "****** Testing Installation of ${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }} from GitHub-hosted PyPI *****"
          
          # Wait for GitHub-hosted PyPI index to update
          echo "â³ Waiting for GitHub-hosted PyPI index to update..."
          sleep 120
          
          # Clear pip cache to ensure fresh download
          echo "ðŸ§¹ Clearing pip cache for fresh installation test..."
          python -m pip cache purge
          
          # Install from the GitHub-hosted PyPI index
          echo "ðŸ“¦ Installing ${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }} from GitHub-hosted PyPI..."
          PYPI_INDEX_URL="https://tzoght.github.io/github-hosted-pypi/"
          
          # Try to install the package from the GitHub-hosted PyPI index
          python -m pip install "${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }}" --extra-index-url "$PYPI_INDEX_URL" --verbose
          
          # Test the import
          echo "ðŸ§ª Testing package import..."
          python -c "${{ env.TEST_IMPORT }}"
          if [ $? -eq 0 ]; then
            echo "âœ… ${{ env.PYPI_LIBRARY_NAME }} successfully installed and imported from GitHub-hosted PyPI!"
            echo "ðŸ“ Installed from: GitHub-hosted PyPI (tzoght.github.io/github-hosted-pypi)"
          else
            echo "âŒ ${{ env.PYPI_LIBRARY_NAME }} import failed after installation from GitHub-hosted PyPI."
            exit 1
          fi
          
          # Verify package details and installation source
          echo "ðŸ“‹ Package installation details:"
          python -m pip show ${{ env.PYPI_LIBRARY_NAME }}
          
          echo "ðŸ”— Verifying package was installed from GitHub:"
          # Extract module name from TEST_IMPORT (e.g., "import stackpy" -> "stackpy")
          MODULE_NAME=$(echo "${{ env.TEST_IMPORT }}" | sed 's/import //')
          python -c "import $MODULE_NAME; print(f'âœ… Package location: {$MODULE_NAME.__file__}')" 2>/dev/null || echo "Could not determine package path"

          
    - name: Create publishing summary
      run: |
        echo "## ðŸŽ‰ Package Published to GitHub-hosted PyPI!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Package:** \`${{ env.PYPI_LIBRARY_NAME }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** \`${{ env.LIB_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**GitHub-hosted PyPI Index:** https://tzoght.github.io/github-hosted-pypi/" >> $GITHUB_STEP_SUMMARY
        echo "**Package Page:** https://tzoght.github.io/github-hosted-pypi/${{ env.PYPI_LIBRARY_NAME }}/" >> $GITHUB_STEP_SUMMARY
        echo "**GitHub Release:** ${{ env.LINK_TO_RELEASES }}" >> $GITHUB_STEP_SUMMARY
        echo "**Index Repository:** https://github.com/tzoght/github-hosted-pypi" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“¦ Install Commands:" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
        echo "# Install from GitHub-hosted PyPI index" >> $GITHUB_STEP_SUMMARY
        echo "pip install ${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }} --extra-index-url https://tzoght.github.io/github-hosted-pypi/" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "# Or install the latest version:" >> $GITHUB_STEP_SUMMARY
        echo "pip install ${{ env.PYPI_LIBRARY_NAME }} --extra-index-url https://tzoght.github.io/github-hosted-pypi/" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "# Or install directly from GitHub:" >> $GITHUB_STEP_SUMMARY
        echo "pip install git+https://github.com/tzoght/${{ env.REPO_NAME }}@${{ env.LIB_VERSION }}" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY


