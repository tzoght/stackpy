name: merge

on:
  push:
    branches: ["main"] # only on main branch

permissions:
  contents: write
  pages: write
  id-token: write
  packages: write

concurrency:
  group: "${{ vars.REPO_NAME }}-${{ github.head_ref || github.ref_name }}"
  cancel-in-progress: false

env:
  ################################## REPOSITORY SPECIFIC ##################################
  # Specifies the Python version to be used in the workflow.
  PYTHON_VERSION: "3.12"
  # Repository name from GitHub variables
  REPO_NAME: "${{ vars.REPO_NAME }}"
  # Conda environment name (typically matches repo name)
  CONDA_ENV: "${{ vars.REPO_NAME }}"
  # PyPI library name (typically matches repo name)
  PYPI_LIBRARY_NAME: "${{ vars.REPO_NAME }}"
  # Repository full name for API calls
  REPO: "tzoght/${{ vars.REPO_NAME }}"
  # A Python import statement used for testing package installation.
  TEST_IMPORT: "${{ vars.TEST_IMPORT_STATEMENT }}"
  # Define the link to the release
  LINK_TO_RELEASES: "https://github.com/tzoght/${{ vars.REPO_NAME }}/releases"
  ####################################### DEFAULT #########################################

  ############################## DEFINED AS REPOSITORY SECRET #############################
  # GitHub token for authentication and package publishing
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # SEMVER_PAT
  SEMVER_PAT: ${{ secrets.SEMVER_GITHUB_PAT }}

jobs:

  pre_check:
    runs-on: ubuntu-latest
    outputs:
        is_semver: ${{ steps.check_message.outputs.is_semver }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        # remove this line if you don't use git-lfs
        with:
          lfs: true

      # remove this job if you don't use git-lfs
      - name: Cache Git LFS objects
        id: cache-lfs
        uses: actions/cache@v4
        with:
          path: .git/lfs
          key: ${{ runner.os }}-git-lfs-${{ hashFiles('.gitattributes') }}
          restore-keys: |
            ${{ runner.os }}-git-lfs-

      # remove this job if you don't use git-lfs
      - name: Pull LFS files if cache miss
        if: steps.cache-lfs.outputs.cache-hit != 'true'
        run: |
          git lfs fetch
          git lfs checkout

      - name: Check Commit Message Format
        id: check_message
        run: |
          commit_message=$(git log --format=%B -n 1 HEAD)
          echo "Commit message: $commit_message"
          # Detect standard semantic versioning
          if [[ $commit_message =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            # echo "name=is_semver::true" >> $GITHUB_ENV
            echo "::set-output name=is_semver::true"
          # Detect multi-line messages that start with a semantic version
          elif echo "$commit_message" | grep -Pzq "^[0-9]+\.[0-9]+\.[0-9]+\n\nAutomatically generated by python-semantic-release"; then
            # echo "name=is_semver::true" >> $GITHUB_ENV
            echo "::set-output name=is_semver::true"
          else
            # echo "name=is_semver::false" >> $GITHUB_E
            echo "::set-output name=is_semver::false"
          fi
      
  merge:
    needs: pre_check
    if: needs.pre_check.outputs.is_semver == 'false'
    runs-on: ubuntu-latest

    steps:
    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: "${{ env.PYTHON_VERSION }}"

    - name: Check-out repository
      uses: actions/checkout@v4
      with:
        # important to keep it at 0 to get all tags
        fetch-depth: 0
        # this token is required for semantic-release
        token: ${{ secrets.SEMVER_GITHUB_PAT || secrets.GITHUB_TOKEN }}
        # remove this line if you don't use git-lfs
        lfs: true

    # remove this job if you don't use git-lfs
    - name: Cache Git LFS objects
      id: cache-lfs
      uses: actions/cache@v4
      with:
        path: .git/lfs
        key: ${{ runner.os }}-git-lfs-${{ hashFiles('.gitattributes') }}
        restore-keys: |
          ${{ runner.os }}-git-lfs-

    # remove this job if you don't use git-lfs
    - name: Pull LFS files if cache miss
      if: steps.cache-lfs.outputs.cache-hit != 'true'
      run: |
        git lfs fetch
        git lfs checkout

    - name: Install dependencies
      run: |
        conda env create -f environment.yml
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda init bash
        conda activate ${{ env.CONDA_ENV }}

    - name: Install ${{ env.PYPI_LIBRARY_NAME }} library using poetry
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda activate ${{ env.CONDA_ENV }}
        poetry install

    - name: Test with pytest
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda activate ${{ env.CONDA_ENV }}
        poetry run pytest tests/ --cov-branch --cov=src/${{ env.PYPI_LIBRARY_NAME }} --cov-report=xml:coverage-reports/coverage.xml
        ls -las coverage-reports/

    - name: SonarQube Scan
      uses: SonarSource/sonarqube-scan-action@v3
      env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

    - name: Configure GitHub Packages for poetry
      run: |
          echo "Initialize Conda"
          eval "$(conda shell.bash hook)"
          conda activate ${{ env.CONDA_ENV }}
          
          # Configure poetry to use GitHub Packages (standard format)
          echo "ðŸ”§ Configuring GitHub Packages repository..."
          poetry config repositories.github https://upload.pypi.pkg.github.com/tzoght/
          poetry config http-basic.github __token__ ${{ env.GITHUB_TOKEN }}
          
          # Verify configuration
          echo "ðŸ“‹ Poetry repository configuration:"
          poetry config --list | grep github || echo "No GitHub config found"
          
          # Test authentication
          echo "ðŸ” Testing GitHub Packages authentication..."
          curl -H "Authorization: token ${{ env.GITHUB_TOKEN }}" https://api.github.com/user || echo "Auth test failed"

    - name: Semantic Release (GitHub Release Only)
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PRE_RELEASE: ${{ env.PRE_RELEASE }}
        SEMVER_PAT: ${{ secrets.SEMVER_GITHUB_PAT }}
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        echo "activating conda environment  ${{ env.CONDA_ENV }}"
        conda activate ${{ env.CONDA_ENV }}
        echo "activated conda environment  ${{ env.CONDA_ENV }}"
        git config user.name github-actions
        git config user.email github-actions@github.com
        poetry run semantic-release publish

    - name: Build and Publish to GitHub Packages
      run: |
        echo "Initialize Conda"
        eval "$(conda shell.bash hook)"
        conda activate ${{ env.CONDA_ENV }}
        
        # Build the package
        echo "ðŸ“¦ Building package..."
        poetry build
        
        # Try poetry publish first
        echo "ðŸš€ Attempting to publish with poetry..."
        if ! poetry publish --repository github; then
          echo "âŒ Poetry publish failed, trying with twine..."
          
          # Install twine if not available
          pip install twine
          
          # Configure twine for GitHub Packages
          export TWINE_USERNAME=__token__
          export TWINE_PASSWORD=${{ env.GITHUB_TOKEN }}
          export TWINE_REPOSITORY_URL=https://upload.pypi.pkg.github.com/tzoght/
          
          # Publish with twine
          echo "ðŸ”„ Publishing with twine to GitHub Packages..."
          twine upload dist/* --repository-url $TWINE_REPOSITORY_URL --verbose
        else
          echo "âœ… Poetry publish succeeded!"
        fi

    - name: Get ${{ env.PYPI_LIBRARY_NAME }} version
      id: get_version
      run: |
          echo "Initialize Conda"
          eval "$(conda shell.bash hook)"
          conda init bash
          conda activate ${{ env.CONDA_ENV }}
          echo "LIB_VERSION=$(poetry version --short)" >> $GITHUB_ENV

    - name: Test installation from GitHub Packages
      run: |
          echo "Initialize Conda"
          eval "$(conda shell.bash hook)"
          conda init bash
          conda create --name test_env python=${{ env.PYTHON_VERSION }}
          conda activate test_env
          echo "****** Testing Installation of ${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }} from GitHub Packages *****"
          
          # Wait for GitHub Packages to propagate the new package
          echo "â³ Waiting for package propagation to GitHub Packages..."
          sleep 90
          
          # Clear pip cache to ensure fresh download
          echo "ðŸ§¹ Clearing pip cache for fresh installation test..."
          python -m pip cache purge
          
          # Ensure we're only using GitHub Packages (no fallback to PyPI)
          echo "ðŸ”§ Configuring pip to use only GitHub Packages..."
          python -m pip config set global.index-url https://__token__:${{ env.GITHUB_TOKEN }}@pypi.pkg.github.com/tzoght/simple/
          python -m pip config set global.trusted-host pypi.pkg.github.com
          python -m pip config set global.no-index false
          
          # Verify the package exists in GitHub Packages
          echo "ðŸ” Checking package availability in GitHub Packages..."
          python -m pip index versions ${{ env.PYPI_LIBRARY_NAME }} || echo "Package may still be propagating..."
          
          # Install the specific version from GitHub Packages
          echo "ðŸ“¦ Installing ${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }} from GitHub Packages..."
          python -m pip install --no-deps --force-reinstall ${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }}
          
          # Test the import
          echo "ðŸ§ª Testing package import..."
          python -c "${{ env.TEST_IMPORT }}"
          if [ $? -eq 0 ]; then
            echo "âœ… ${{ env.PYPI_LIBRARY_NAME }} successfully installed and imported from GitHub Packages!"
            echo "ðŸ“ Installed from: GitHub Packages (pypi.pkg.github.com/tzoght)"
          else
            echo "âŒ ${{ env.PYPI_LIBRARY_NAME }} import failed after installation from GitHub Packages."
            exit 1
          fi
          
          # Verify package details and installation source
          echo "ðŸ“‹ Package installation details:"
          python -m pip show ${{ env.PYPI_LIBRARY_NAME }}
          
          echo "ðŸ”— Verifying package was installed from GitHub Packages:"
          # Extract module name from TEST_IMPORT (e.g., "import stackpy" -> "stackpy")
          MODULE_NAME=$(echo "${{ env.TEST_IMPORT }}" | sed 's/import //')
          python -c "import $MODULE_NAME; print(f'âœ… Package location: {$MODULE_NAME.__file__}')" 2>/dev/null || echo "Could not determine package path"
          
          # Double-check that we're not accidentally using PyPI
          echo "ðŸš« Confirming NO fallback to PyPI occurred:"
          python -m pip config list | grep -i index-url || echo "No index-url configured (good)"

    - name: Create publishing summary
      run: |
        echo "## ðŸŽ‰ Package Published to GitHub Packages!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Package:** \`${{ env.PYPI_LIBRARY_NAME }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** \`${{ env.LIB_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**GitHub Packages URL:** https://github.com/tzoght/${{ env.REPO_NAME }}/packages" >> $GITHUB_STEP_SUMMARY
        echo "**GitHub Release:** ${{ env.LINK_TO_RELEASES }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“¦ Install Commands:" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
        echo "# Install from GitHub Packages (requires authentication)" >> $GITHUB_STEP_SUMMARY
        echo "pip install --index-url https://pypi.pkg.github.com/tzoght/simple/ ${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "# Or configure pip globally:" >> $GITHUB_STEP_SUMMARY
        echo "pip config set global.index-url https://pypi.pkg.github.com/tzoght/simple/" >> $GITHUB_STEP_SUMMARY
        echo "pip install ${{ env.PYPI_LIBRARY_NAME }}==${{ env.LIB_VERSION }}" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY


